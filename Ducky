local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local requestFunc = (syn and syn.request) or (http and http.request) or request
if not requestFunc then
    warn("Your executor does not support HTTP requests.")
    return
end

local player = Players.LocalPlayer
local userid = player.UserId
local username = player.Name



loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()
local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()


local Window = Library:Window{
    Title = "Tap Infinity",
    SubTitle = "By Duckie",
    TabWidth = 160,
    Size =  UDim2.fromOffset(580, 460),
    Resize = false, 
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}


local Tabs = {
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
    Main = Window:AddTab({ Title = "Main", Icon = "mouse-pointer-click" }),
    Egg = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
    Breakables = Window:AddTab({ Title = "Breakables", Icon = "hammer" }),
    Upgrades = Window:AddTab({ Title = "Upgrades", Icon = "wrench" }),
    Aura = Window:AddTab({ Title = "Auras", Icon = "sparkles" }),
    Merchant = Window:AddTab({ Title = "Merchant", Icon = "shopping-cart" }),
    Pet = Window:AddTab({ Title = "Pets", Icon = "paw-print" }),
}

-- Services and Game References
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

-- Game Data
local RebirthData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Rebirths"))
local Zones = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Zones"))
local TapEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TapEvent")
local RebirthEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("RebirthEvent")

-- Player References
local LocalPlayer = Players.LocalPlayer
local Data = LocalPlayer:WaitForChild("Data")

-- UI Section
local AutoFarmSection = Tabs.Main:AddSection("Auto Farm")

local autoTapEnabled = false
local autoTapThread = nil
local tapInterval = 0.05 -- Changed to 0.05 per your original code

local autoRebirthEnabled = false
local autoRebirthThread = nil

-- Client Modules
local ClientTap, Teleport

-- Load client modules safely
local function loadClientModules()
    pcall(function()
        ClientTap = require(ReplicatedFirst.Actor.ClientMain.ClientTap)
        if ClientTap then
            ClientTap.Animation = function() return true end
        end
    end)
    pcall(function()
        Teleport = require(ReplicatedFirst.Actor.ClientMain.ClientInterface.Teleport)
    end)
end

-- Call this once at script start
loadClientModules()

-- Function to get rebirth options with Max at the beginning
local function getRebirthOptions()
    local options = {"Max"}  -- Put "Max" at the beginning of the list
    local rebirthsBonus = Data:WaitForChild("RebirthsBonus").Value
    
    for i, rebirthInfo in pairs(RebirthData) do
        -- Skip the last option (usually unlimited rebirth)
        if i == #RebirthData then continue end
        
        -- Include all options but mark if they're unlocked
        table.insert(options, tostring(rebirthInfo.reward))
    end
    
    return options
end

-- Function to find rebirth index from reward value or "Max"
local function findRebirthIndexByReward(reward)
    if reward == "Max" then
        -- Find best owned rebirth regardless of affordability
        local bestIndex = 1
        local highestReward = 0
        
        for i, rebirthInfo in pairs(RebirthData) do
            if i == #RebirthData then continue end
            
            local isUnlocked = (Data:WaitForChild("RebirthsBonus").Value * 10 + 1 >= i)
            if not isUnlocked then continue end
            
            -- Only check if it's the highest reward, not if we can afford it
            if rebirthInfo.reward > highestReward then
                bestIndex = i
                highestReward = rebirthInfo.reward
            end
        end
        
        return bestIndex
    end
    
    local rewardNumber = tonumber(reward)
    for i, rebirthInfo in pairs(RebirthData) do
        if i == #RebirthData then continue end
        if rebirthInfo.reward == rewardNumber then
            return i
        end
    end
    
    return 1 -- Default to first rebirth if not found
end

-- Function to calculate rebirth cost
local function calculateCost(rebirthInfo)
    return (Data:WaitForChild("Rebirths").Value + 1) * 75 * rebirthInfo.reward
end

local function getBestZoneName()
    local highestPos = -math.huge
    local bestZone = nil

    for zoneName, zoneData in pairs(Zones) do
        if zoneData.pos and zoneData.pos > highestPos then
            highestPos = zoneData.pos
            bestZone = zoneName
        end
    end

    return bestZone or "Spawn"
end

-- Perform tap in best zone
local function performTap()
    pcall(function()
        local bestZone = getBestZoneName()
        TapEvent:FireServer(LocalPlayer, bestZone)
    end)
end

-- Perform rebirth by index
local function performRebirth(rebirthIndex)
    pcall(function()
        RebirthEvent:FireServer(rebirthIndex)
    end)
end

-- Start auto tap loop
local function startAutoTap()
    if autoTapThread then return end
    autoTapEnabled = true
    autoTapThread = task.spawn(function()
        while autoTapEnabled do
            performTap()
            task.wait(tapInterval)
        end
    end)
end

-- Stop auto tap loop
local function stopAutoTap()
    if autoTapThread then
        autoTapEnabled = false
        task.cancel(autoTapThread)
        autoTapThread = nil
    end
end



-- Auto Tap Toggle
local AutoTapToggle = AutoFarmSection:AddToggle("AutoTap", {
    Title = "Auto Tap",
    Description = "Click extremely fast, with the best zone's worldboost! You don't even need to have unlocked the zone!",
    Default = false
})

-- Rebirth Selection Dropdown
local RebirthDropdown = AutoFarmSection:AddDropdown("RebirthSelect", {
    Title = "Select Rebirth Amount",
    Description = "Select the amount of rebirths to perform. You don't even need to have the upgrade! If you select 'Max', it will perform the best rebirth you have unlocked.",
    Values = getRebirthOptions(),
    Searchable = true,
    Default = "Max",
    Multi = false
})


-- Auto Rebirth Toggle
local AutoRebirthToggle = AutoFarmSection:AddToggle("AutoRebirth", {
    Title = "Auto Rebirth",
    Description = "Automatically rebirth when you have enough taps",
    Default = false
})


-- Load client modules
loadClientModules()



task.spawn(function()
    while true do
        task.wait(5)
        
        local currentSelection = RebirthDropdown.Value
        local newOptions = getRebirthOptions()
        
        -- Check if options changed
        local optionsChanged = false
        if #RebirthDropdown.Values ~= #newOptions then
            optionsChanged = true
        else
            for i, option in ipairs(newOptions) do
                if option ~= RebirthDropdown.Values[i] then
                    optionsChanged = true
                    break
                end
            end
        end
        
        if optionsChanged then
            RebirthDropdown:SetValues(newOptions)
            
            -- Try to preserve selection
            for _, option in ipairs(newOptions) do
                if option == currentSelection then
                    RebirthDropdown:SetValue(currentSelection)
                    break
                end
            end
        end
    end
end)

-- Connect auto tap toggle
AutoTapToggle:OnChanged(function(Value)
    autoTapEnabled = Value
    
    if autoTapEnabled then
        startAutoTap()
    else
        stopAutoTap()
    end
end)

AutoRebirthToggle:OnChanged(function(Value)
    autoRebirthEnabled = Value

    -- Cancel existing thread if running
    if autoRebirthThread then
        task.cancel(autoRebirthThread)
        autoRebirthThread = nil
    end

    if autoRebirthEnabled then
        autoRebirthThread = task.spawn(function()
            while autoRebirthEnabled do
                pcall(function()
                    local selectedReward = RebirthDropdown.Value
                    if not selectedReward then return end

                    local rebirthIndex = findRebirthIndexByReward(selectedReward)
                    local rebirthInfo = rebirthIndex and RebirthData[rebirthIndex]
                    if not rebirthInfo then return end

                    local cost = calculateCost(rebirthInfo)
                    local currentTaps = Data:WaitForChild("Taps").Value

                    if currentTaps >= cost then
                        performRebirth(rebirthIndex)
                    end
                end)

                task.wait(0.5)
            end
        end)
    end
end)

-- Add Input for Best Rebirth Delay
local BestRebirthDelay = AutoFarmSection:AddInput("BestRebirthDelay", {
    Title = "Best Rebirth Delay (Seconds)",
    Default = "5",
    Placeholder = "Enter the rebirth delay in seconds",
    Numeric = true,
    Finished = false,
    Callback = function(Value) end
})

-- Variables for Auto Best Rebirth
local autoBestRebirthEnabled = false
local autoBestRebirthThread = nil

-- Add toggle for Auto Best Rebirth
local AutoBestRebirthToggle = AutoFarmSection:AddToggle("AutoBestRebirth", {
    Title = "Auto Best Rebirth",
    Description = "Automatically performs the best rebirth you can afford every X seconds",
    Default = false
})

-- Function to get the best affordable rebirth
local function getBestAffordableRebirth()
    -- Load rebirth data
    local RebirthData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Rebirths"))
    local currentTaps = Data:WaitForChild("Taps").Value
    local currentRebirths = Data:WaitForChild("Rebirths").Value
    
    local bestRebirthIndex = 0
    local bestReward = 0
    local bestCost = 0
    
    for i, rebirthInfo in pairs(RebirthData) do
        if i == #RebirthData then continue end -- Skip the last rebirth (usually unlimited)
        
        -- Calculate cost and check if unlocked
        local cost = (currentRebirths + 1) * 75 * rebirthInfo.reward
        local reward = rebirthInfo.reward
        local isUnlocked = (Data:WaitForChild("RebirthsBonus").Value * 10 + 1 >= i)
        local canAfford = currentTaps >= cost
        
        -- Track the best affordable rebirth
        if isUnlocked and canAfford and reward > bestReward then
            bestRebirthIndex = i
            bestReward = reward
            bestCost = cost
        end
    end
    
    return bestRebirthIndex, bestReward, bestCost
end
-- Connect auto best rebirth toggle
AutoBestRebirthToggle:OnChanged(function(Value)
    autoBestRebirthEnabled = Value
    
    -- Cancel existing thread if running
    if autoBestRebirthThread then
        task.cancel(autoBestRebirthThread)
        autoBestRebirthThread = nil
    end
    
    if autoBestRebirthEnabled then
        autoBestRebirthThread = task.spawn(function()
            while autoBestRebirthEnabled do
                local bestRebirthIndex, bestReward, bestCost = getBestAffordableRebirth()
                
                -- If a rebirth is affordable, perform it without notification
                if bestRebirthIndex > 0 then
                    performRebirth(bestRebirthIndex)
                end
                
                -- Wait for the user-specified delay
                local delaySeconds = tonumber(BestRebirthDelay.Value) or 5
                task.wait(delaySeconds)
            end
        end)
    end
end)


local Zones = Tabs.Main:AddSection("Unlock all Zones")

-- Get the zones data
local ZonesData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Zones"))
local TeleportEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("TeleportEvent")

-- Create a button to unlock all zones
Zones:AddButton({
    Title = "Unlock All Zones (Permanent)",
    Description = "Instantly unlock all zones in the game (rergardless of taps)",
    Callback = function()
        -- Get all available zones
        local zoneNames = {}
        for zoneName, _ in pairs(ZonesData) do
            table.insert(zoneNames, zoneName)
        end
        
        -- Sort zone names by position if available
        table.sort(zoneNames, function(a, b)
            local posA = ZonesData[a].pos or 0
            local posB = ZonesData[b].pos or 0
            return posA < posB
        end)
        
        -- Unlock each zone one by one
        for _, zoneName in ipairs(zoneNames) do
            local zoneData = ZonesData[zoneName]
            
            -- Modify cost to 1 to ensure it can be unlocked
            local modifiedZoneData = {}
            for k, v in pairs(zoneData) do
                modifiedZoneData[k] = v
            end
            modifiedZoneData.cost = 1
            
            -- Fire teleport event to unlock the zone
            TeleportEvent:FireServer(zoneName, modifiedZoneData)
            
            -- Small delay to prevent server overload
            task.wait(0.1)
        end
    end
})

-- Variables for control
local AutoHatchEnabled = false
local EggEvent = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("EggEvent")
local EggFunction = game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("EggFunction")

-- Create UI
local EggTab = Tabs.Egg:AddSection("Eggs")



-- Create a function to get all available eggs from the game
local function getAvailableEggs()
    local eggData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Eggs"))
    local eggNames = {}
    
    for _, egg in pairs(eggData) do
        -- Skip eggs that cost Robux
        if not egg.takesRobux then
            table.insert(eggNames, egg.name)
        end
    end
    
    -- Sort the egg names alphabetically
    table.sort(eggNames)
    
    return eggNames
end

local function getPetsFromEgg(eggName)
    local eggData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Eggs"))
    local petNames = {}
    
    for _, egg in pairs(eggData) do
        if egg.name == eggName then
            for _, pet in pairs(egg.pets) do
                table.insert(petNames, pet[1]) -- pet[1] is the pet name
            end
            break
        end
    end
    
    -- Sort the pet names alphabetically
    table.sort(petNames)
    
    return petNames
end

-- Create egg selection dropdown with dynamic values
local EggDropdown = EggTab:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = getAvailableEggs(),
    Multi = false,
    Searchable = true,
    Default = "Basic Egg"
})

-- Create hatch amount dropdown
local HatchAmountDropdown = EggTab:AddDropdown("HatchAmount", {
    Title = "Hatch Amount",
    Description = "You will need to have joint the group for 3x, and have brought the 8x gamepass for 8x.",
    Values = {"1", "3", "8"},
    Multi = false,
    Default = "1"
})

local Delete = EggTab:AddDropdown("DeletePets", {
    Title = "Auto Delete Pets",
    Description = "Select pets to auto delete.",
    Values = getPetsFromEgg(EggDropdown.Value),
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Update the delete dropdown when the egg selection changes
EggDropdown:OnChanged(function(value)
    Delete:SetValues(getPetsFromEgg(value))
end)


-- Create auto hatch toggle
local AutoHatchToggle = EggTab:AddToggle("AutoHatch", {
    Title = "Auto Hatch",
    Description = "Automatically hatch eggs",
    Default = false
})

-- Hook the Egg Hatching System
local function hookEggSystem()
    -- References to necessary components
    local ReplicatedFirst = game:GetService("ReplicatedFirst")
    local Actor = ReplicatedFirst:WaitForChild("Actor")
    local ClientMain = Actor:WaitForChild("ClientMain")
    local ClientInterface = ClientMain:WaitForChild("ClientInterface")
    local EggsModule = ClientInterface:WaitForChild("Eggs")
    local ClientEgg = ClientMain:WaitForChild("ClientEgg")
    
    -- Try to load the modules
    local originalEggsModule = require(EggsModule)
    local clientEggModule = require(ClientEgg)
    
    -- Create a hook for the ClientEgg module
    local clientEggHook = {}
    for k, v in pairs(clientEggModule) do
        clientEggHook[k] = v
    end
    
    -- Override OpeningEgg to always be false, effectively disabling animations
    clientEggHook.OpeningEgg = false
    clientEggHook.AutoHatching = false
    
    -- Create a proxy for the setter to intercept when the game tries to set OpeningEgg to true
    setmetatable(clientEggHook, {
        __newindex = function(t, k, v)
            if k == "OpeningEgg" and v == true then
                -- Prevent OpeningEgg from being set to true
                rawset(t, k, false)
            else
                -- Allow other properties to be modified
                rawset(t, k, v)
            end
        end
    })
    
    -- Delete the egg frames GUI if it exists
    local player = game:GetService("Players").LocalPlayer
    if player and player:FindFirstChild("PlayerGui") then
        local eggFrames = player.PlayerGui:FindFirstChild("Egg")
        if eggFrames then
            eggFrames:Destroy()
        end
    end
    
    -- Remove the blur effect
    local lighting = game:GetService("Lighting")
    local blur = lighting:FindFirstChild("Blur")
    if blur then
        blur.Enabled = false
    end
    
    -- Replace the original module
    _G.OriginalClientEgg = clientEggModule
    _G.HookedClientEgg = clientEggHook
    
    -- Hook the Eggs module in ClientInterface
    local eggsHook = {}
    for k, v in pairs(originalEggsModule) do
        if type(v) == "function" then
            eggsHook[k] = function(...)
                -- Skip the Open function animations
                if k == "Open" then
                    clientEggHook.OpeningEgg = false
                    return
                end
                
                -- For all other functions, just call the original
                return v(...)
            end
        else
            -- Copy non-function values
            eggsHook[k] = v
        end
    end
    
    -- Replace the Open function to skip animations entirely
    eggsHook.Open = function(self, eggName, petsHatched, isNew)
        clientEggHook.OpeningEgg = false
        return
    end
    
    -- Store the original module
    _G.OriginalEggsModule = originalEggsModule
    _G.HookedEggsModule = eggsHook
    
    -- Try to replace the modules in memory
    pcall(function()
        if game.HttpService then
            setrawmetatable = getrawmetatable or getmetatable
            
            -- Try to replace the modules directly
            local oldClientEgg = require(ClientEgg)
            for k, v in pairs(clientEggHook) do
                oldClientEgg[k] = v
            end
            
            local oldEggsModule = require(EggsModule)
            for k, v in pairs(eggsHook) do
                oldEggsModule[k] = v
            end
        end
    end)
    
    -- Create a loop to ensure OpeningEgg stays false
    local loopThread = task.spawn(function()
        while task.wait(0.1) do
            -- Keep checking and forcing OpeningEgg to false
            if clientEggHook.OpeningEgg == true then
                clientEggHook.OpeningEgg = false
            end
            
            -- Also check for any new egg frames GUI and remove them
            local playerGui = player:FindFirstChild("PlayerGui")
            if playerGui then
                local newEggFrames = playerGui:FindFirstChild("Egg")
                if newEggFrames then
                    newEggFrames:Destroy()
                end
            end
            
            -- Keep blur disabled
            if blur and blur.Enabled then
                blur.Enabled = false
            end
        end
    end)
    
    -- Store the loop thread so we can cancel it if needed
    _G.EggHookThread = loopThread
    
    return true
end

-- Add button to skip egg animations
EggTab:AddButton({
    Title = "Skip Egg Animations",
    Description = "Skips the egg hatching animation. Don't click this if you are currently mid hatch.",
    Callback = function()
        local success = hookEggSystem()
        if success then
            -- No need for notification
        end
    end
})

-- Function to hatch eggs
local function hatchEgg()
    local eggName = EggDropdown.Value
    local hatchAmount = tonumber(HatchAmountDropdown.Value)
    
    -- Safety check
    if not eggName or not hatchAmount then return end
    
    -- Check if any egg is currently being opened
    local ClientEgg
    pcall(function()
        ClientEgg = require(ReplicatedFirst.Actor.ClientMain.ClientEgg)
    end)
    
    if ClientEgg and ClientEgg.OpeningEgg then
        return -- Skip if already opening an egg
    end
    
    local petsToDelete = {}
    for petName, selected in pairs(Delete.Value) do
        if selected then
            table.insert(petsToDelete, petName)
        end
    end
    
    -- Send hatch request to server using the correct format
    local success, result = pcall(function()
        return EggFunction:InvokeServer(
            "Buy",  
            eggName, 
            hatchAmount, 
            petsToDelete -- Now correctly formatted as an array
        )
    end)
    
    
    if not success then
    end
end

-- Auto hatch loop
AutoHatchToggle:OnChanged(function(value)
    AutoHatchEnabled = value
    
    if value then
        task.spawn(function()
            while AutoHatchEnabled do
                hatchEgg()
                task.wait(0.5) -- Wait half a second between hatches
            end
        end)
    end
end)



local Breakables = Tabs.Breakables:AddSection("Auto Break")

-- Get necessary services
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Get the ClientBreakables module
local ClientBreakables
pcall(function()
    ClientBreakables = require(ReplicatedFirst:WaitForChild("Actor"):WaitForChild("ClientMain"):WaitForChild("ClientBreakables"))
end)

-- Function to simulate a proper mouse click
local function simulateMouseClick(position)
    local position = position or Vector2.new(
        workspace.CurrentCamera.ViewportSize.X - 50,  -- 50 pixels from right edge
        50  -- 50 pixels from top
    )
    
    -- Simulate mouse movement to position
    VirtualInputManager:SendMouseMoveEvent(position.X, position.Y, game)
    
    -- Simulate mouse button down (click)
    VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, true, game, 1)
    
    -- Small delay between down and up
    task.wait(0.01)
    
    -- Simulate mouse button up (release)
    VirtualInputManager:SendMouseButtonEvent(position.X, position.Y, 0, false, game, 1)
end



-- Add a toggle for auto-clicking
local autoClickEnabled = false
local autoClickThread = nil

local autoclickbreakables = Breakables:AddToggle("AutoClick", {
    Title = "Auto Break Breakables",
    Description = "This simulates real mouse clicks, so dont press anything other then the toggle when this is enabled. Use the ingame auto break for the best results.",
    Default = false,
    Callback = function(Value)
        autoClickEnabled = Value
        
        if autoClickEnabled then
            autoClickThread = task.spawn(function()
                while autoClickEnabled do
                    local position = Vector2.new(
                        workspace.CurrentCamera.ViewportSize.X - 50,
                        50
                    )
                    simulateMouseClick(position)
                    task.wait(0.1) -- Small delay between clicks
                end
            end)
        else
            if autoClickThread then
                task.cancel(autoClickThread)
                autoClickThread = nil
            end
        end
    end
})

Breakables:AddButton({
    Title = "Stop Auto Break",
    Description = "If the toggle is glitching and not turning off, use this to imeddiately stop the auto click (spam click until the toggle turns off).",
    Callback = function()
        autoclickbreakables:SetValue(false)
    end
})

local breakableupgrades = Tabs.Breakables:AddSection("Breakable Upgrades")

-- UI Section - Combined dropdown for both display and auto-buy
local UpgradeDropdown = breakableupgrades:AddDropdown("SelectUpgrades", {
    Title = "Select Upgrades",
    Description = "Select which upgrades to display and auto-buy when affordable",
    Values = {}, -- Empty for now
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Add toggle for Auto Buy Selected
local autoBuyEnabled = false
local autoBuyThread = nil

local AutoBuyToggle = breakableupgrades:AddToggle("AutoBuy", {
    Title = "Auto Buy Selected Upgrades",
    Description = "Automatically buy the selected upgrades when you can afford them.",
    Default = false
})



-- Load BreakableUpgrades data
local BreakableUpgradesData
pcall(function()
    BreakableUpgradesData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("BreakableUpgrades"))
end)

-- Function to populate the dropdown
local function populateUpgradeDropdown()
    if not BreakableUpgradesData then return end

    local upgradeNames = {}
    for upgradeName in pairs(BreakableUpgradesData) do
        if upgradeName ~= "Fireworks" then
            table.insert(upgradeNames, upgradeName)
        end
    end

    table.sort(upgradeNames)
    UpgradeDropdown:SetValues(upgradeNames)
end

-- Function to check if player can afford the upgrade
local function canAffordUpgrade(upgradeName)
    if not BreakableUpgradesData or not upgradeName then return false end
    
    local PlayerGems = Data:WaitForChild("Gems").Value
    local BreakableUpgradesProgress = Data:WaitForChild("BreakableUpgradesProgress")
    local upgradeData = BreakableUpgradesData[upgradeName]
    
    if not upgradeData then return false end
    
    local currentLevel = BreakableUpgradesProgress:FindFirstChild(upgradeName) and 
                       BreakableUpgradesProgress[upgradeName].Value or 0
    
    local nextCost = 0
    
    -- Calculate cost for the next level
    if type(upgradeData) == "table" and upgradeData[1] and upgradeData[1].cost then
        -- Array-based cost structure
        if upgradeData[currentLevel] then
            nextCost = upgradeData[currentLevel].cost
            local currency = upgradeData[currentLevel].currency or "Gems"
            if currency ~= "Gems" then return false end
        else
            return false -- Already at max level
        end
    elseif type(upgradeData) == "table" and upgradeData.price then
        -- Formula-based cost structure
        local basePrice = upgradeData.price
        local multiplier = upgradeData.multi or 1.5
        nextCost = basePrice * (multiplier ^ (currentLevel-1))
        local currency = upgradeData.currency or "Gems"
        if currency ~= "Gems" then return false end
    else
        return false
    end
    
    return PlayerGems >= nextCost
end

-- Handle auto buy selected upgrades logic
AutoBuyToggle:OnChanged(function(Value)
    autoBuyEnabled = Value
    
    -- Cancel existing thread if running
    if autoBuyThread then
        task.cancel(autoBuyThread)
        autoBuyThread = nil
    end
    
    if autoBuyEnabled then
        autoBuyThread = task.spawn(function()
            while autoBuyEnabled do
                local selectedUpgrades = UpgradeDropdown.Value or {}
                
                -- Try to purchase each selected upgrade
                for upgradeName, isSelected in pairs(selectedUpgrades) do
                    if isSelected then
                        -- Only buy if player can afford it
                        if canAffordUpgrade(upgradeName) then
                            pcall(function()
                                local BreakableFunction = ReplicatedStorage.Remotes.BreakableFunction
                                BreakableFunction:InvokeServer(upgradeName, false)
                            end)
                            task.wait(0.1) -- Small delay between purchases
                        end
                    end
                end
                
                task.wait(0.5) -- Check every half second
            end
        end)
    end
end)


-- Populate the dropdown when data is ready
task.spawn(function()
    while not BreakableUpgradesData do
        task.wait(1)
        pcall(function()
            BreakableUpgradesData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("BreakableUpgrades"))
        end)
    end
    populateUpgradeDropdown()
end)
local UpgradesSection = Tabs.Upgrades:AddSection("Stat Upgrades")

-- Function to get upgrade types from the module
local function getUpgradeTypes()
    local UpgradesData
    pcall(function()
        UpgradesData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Upgrades"))
    end)

    if not UpgradesData then
        return {"Taps", "Rebirths", "Gems", "Luck", "HatchSpeed"} -- Default values
    end

    local upgradeTypes = {}
    for _, tierData in pairs(UpgradesData) do
        for upgradeName, _ in pairs(tierData) do
            if not table.find(upgradeTypes, upgradeName) then
                table.insert(upgradeTypes, upgradeName)
            end
        end
    end

    table.sort(upgradeTypes)
    return upgradeTypes
end

-- Create the dropdown with dynamic values
local upgradedropdown = UpgradesSection:AddDropdown("SelectUpgrades", {
    Title = "Select Upgrades",
    Description = "Select which upgrades to buy.",
    Values = getUpgradeTypes(),
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Add toggle for Auto Buy All Affordable Upgrades
local autoBuyAllEnabled = false
local autoBuyAllThread = nil

-- Function to check which upgrades are affordable
local function getAffordableUpgrades()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer
    local Data = LocalPlayer:WaitForChild("Data")

    local UpgradesData
    pcall(function()
        UpgradesData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Upgrades"))
    end)

    if not UpgradesData then
        return {}
    end

    local UpgradesProgress = Data:WaitForChild("UpgradesProgress")
    local PlayerGems = Data:WaitForChild("Gems").Value

    local affordableUpgrades = {}

    for _, tierFolder in pairs(UpgradesProgress:GetChildren()) do
        local tierName = tierFolder.Name

        for _, upgradeValue in pairs(tierFolder:GetChildren()) do
            local upgradeName = upgradeValue.Name
            local level = upgradeValue.Value

            -- Skip if max level reached
            if level >= 5 then continue end

            local nextCost = nil
            if UpgradesData[tierName] and UpgradesData[tierName][upgradeName] then
                nextCost = UpgradesData[tierName][upgradeName][level + 1]
            end

            if nextCost and PlayerGems >= nextCost then
                table.insert(affordableUpgrades, {
                    name = upgradeName,
                    tier = tonumber(tierName),
                    level = level + 1,
                    cost = nextCost
                })
            end
        end
    end

    return affordableUpgrades
end

-- Add toggle for Auto Buy Affordable Upgrades
UpgradesSection:AddToggle("AutoBuyUpgrades", {
    Title = "Auto Buy Affordable Upgrades",
    Description = "Automatically purchase upgrades when you can afford them",
    Default = false,
    Callback = function(Value)
        autoBuyAllEnabled = Value

        if autoBuyAllThread then
            task.cancel(autoBuyAllThread)
            autoBuyAllThread = nil
        end

        if autoBuyAllEnabled then
            autoBuyAllThread = task.spawn(function()
                while autoBuyAllEnabled do
                    local affordableUpgrades = getAffordableUpgrades()

                    table.sort(affordableUpgrades, function(a, b)
                        return a.cost < b.cost
                    end)

                    for _, upgrade in ipairs(affordableUpgrades) do
                        local selectedUpgrades = upgradedropdown.Value or {}
                        if selectedUpgrades[upgrade.name] then
                            pcall(function()
                                local UpgradesEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("UpgradesEvent")
                                UpgradesEvent:FireServer(
                                    tostring(upgrade.tier),
                                    upgrade.name
                                )
                            end)
                            task.wait(0.1)
                        end
                    end

                    task.wait(1)
                end
            end)
        end
    end
})

-- Try to update the dropdown values once when the module is available
task.spawn(function()
    local attempts = 0
    local maxAttempts = 1

    while attempts < maxAttempts do
        local upgradeTypes = getUpgradeTypes()
        if #upgradeTypes > 0 and upgradeTypes[1] ~= "Taps" then
            upgradedropdown:SetValues(upgradeTypes)
            break
        end

        attempts = attempts + 1
        task.wait(1)
    end
end)

-- Add Auto Open Chests section to Aura tab
local OpenChestSection = Tabs.Aura:AddSection("Auto Open Chests")

-- Function to get all available chest types
local function getAvailableChestTypes()
    local ChestsData
    pcall(function()
        ChestsData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Chests"))
    end)
    
    if not ChestsData then
        return {}
    end
    
    local chestTypes = {}
    for chestName in pairs(ChestsData) do
        table.insert(chestTypes, chestName)
    end
    
    -- Sort alphabetically
    table.sort(chestTypes)
    
    return chestTypes
end

-- Create dropdown for selecting chests to auto-open
local ChestOpenDropdown = OpenChestSection:AddDropdown("ChestOpenSelect", {
    Title = "Select Chests to Open",
    Description = "Choose which chests to automatically open",
    Values = getAvailableChestTypes(),
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Add toggle for Auto Open Chests
local autoOpenChestsEnabled = false
local autoOpenChestsThread = nil

local AutoOpenChestsToggle = OpenChestSection:AddToggle("AutoOpenChests", {
    Title = "Auto Open Chests",
    Description = "Automatically opens selected chests (if you have them).",
    Default = false
})

-- Handle auto open chests logic
AutoOpenChestsToggle:OnChanged(function(Value)
    autoOpenChestsEnabled = Value
    
    -- Cancel existing thread if running
    if autoOpenChestsThread then
        task.cancel(autoOpenChestsThread)
        autoOpenChestsThread = nil
    end
    
    if autoOpenChestsEnabled then
        autoOpenChestsThread = task.spawn(function()
            while autoOpenChestsEnabled do
                -- Get all selected chests
                local selectedChests = ChestOpenDropdown.Value or {}
                
                -- Create a list of chests that player has
                local availableSelectedChests = {}
                local ChestAmounts = Data:WaitForChild("ChestAmounts")
                
                for chestName, isSelected in pairs(selectedChests) do
                    if isSelected then
                        -- Check if player has this chest
                        local chestValue = ChestAmounts:FindFirstChild(chestName)
                        if chestValue and chestValue.Value > 0 then
                            table.insert(availableSelectedChests, chestName)
                        end
                    end
                end
                
                -- If player has any of the selected chests, open a random one
                if #availableSelectedChests > 0 then
                    -- Choose a random chest to open
                    local randomIndex = math.random(1, #availableSelectedChests)
                    local chestToOpen = availableSelectedChests[randomIndex]
                    
                    -- Open the chest using AurasFunction
                    pcall(function()
                        local AurasFunction = ReplicatedStorage.Remotes.AurasFunction
                        AurasFunction:InvokeServer(chestToOpen)
                    end)
                end
                
                -- Wait 2 seconds before the next chest open
                task.wait(1)
            end
        end)
    end
end)

-- Update chest types dropdown when chest data becomes available
task.spawn(function()
    local attempts = 0
    local maxAttempts = 1
    
    while attempts < maxAttempts do
        local chestTypes = getAvailableChestTypes()
        if #chestTypes > 0 then
            ChestOpenDropdown:SetValues(chestTypes)
            break
        end
        
        attempts = attempts + 1
        task.wait(3)
    end
end)

-- Add a paragraph to display auto-opening status
local OpenStatusParagraph = OpenChestSection:AddParagraph("ChestOpenStatus", {
    Title = "Auto Open Status",
    Content = "Loading status information..."
})

-- Function to update the auto open status paragraph
local function updateOpenStatusParagraph()
    local ChestAmounts = Data:WaitForChild("ChestAmounts")
    
    -- Try to load chest data for additional info
    local ChestsData
    pcall(function()
        ChestsData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Chests"))
    end)
    
    -- Get data for all chests
    local allChests = {}
    local selectedChests = ChestOpenDropdown.Value or {}
    
    -- First gather all available chest types from the data module
    for chestName, chestData in pairs(ChestsData or {}) do
        local luck = chestData.luck or 0
        local amount = 0
        local isSelected = selectedChests[chestName] or false
        
        -- Check if player has this chest
        local chestValue = ChestAmounts:FindFirstChild(chestName)
        if chestValue then
            amount = chestValue.Value
        end
        
        table.insert(allChests, {
            name = chestName,
            amount = amount,
            luck = luck,
            selected = isSelected
        })
    end
    
    -- Sort by amount (highest first)
    table.sort(allChests, function(a, b)
        if a.amount ~= b.amount then
            return a.amount > b.amount
        else
            return a.luck > b.luck
        end
    end)
    
    -- Format the output showing all chests
    local content = string.format("%-20s %-10s %-10s %-10s\n", "Chest Name", "Amount", "Luck", "Selected")
    content = content .. "------------------------------------------------\n"
    
    local totalChests = 0
    local totalSelectedChests = 0
    
    for _, chest in ipairs(allChests) do
        local selectedText = chest.selected and "✓" or "✗"
        
        content = content .. string.format("%-20s %-10s %-10s %-10s\n", 
            chest.name, 
            "x" .. chest.amount, 
            "x" .. chest.luck,
            selectedText)
        
        totalChests = totalChests + chest.amount
        if chest.selected and chest.amount > 0 then
            totalSelectedChests = totalSelectedChests + chest.amount
        end
    end
    
    content = content .. "------------------------------------------------\n"
    content = content .. "Total Chests: " .. totalChests .. "\n"
    content = content .. "Selected Available: " .. totalSelectedChests
    
    OpenStatusParagraph:SetValue(content)
end

-- Update the open status paragraph regularly
task.spawn(function()
    while true do
        updateOpenStatusParagraph()
        task.wait(2)
    end
end)

local petequip = Tabs.Pet:AddSection("+1 Pet Equip")

-- Add button to set max equipped pets to 10
petequip:AddButton({
    Title = "Get a free extra pet equip.",
    Description = "You will need to manually equip the extra pet, as equip best won't work.",
    Callback = function()
        local maxEquipedPets = game:GetService("Players").LocalPlayer.Data:FindFirstChild("MaxEquipedPets")

        if maxEquipedPets then
            local success, err = pcall(function()
                maxEquipedPets.Value += 1
            end)
        end
    end
})

local notepet = petequip:AddParagraph("Note", {
    Title = "Note",
    Content = "This will reset when you rejoin, but it will give you +1 pet equip (I believe it will only work if you don't own the gamepasses.)"
})



local rubyPet = Tabs.Pet:AddSection("Ruby Machine")

-- Function to get all pets (no filtering)
local function getAllPets()
    local petList = {}
    local petCounts = {}
    local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")

    for _, child in pairs(Pets:GetChildren()) do
        local petName = child.Name
        if petCounts[petName] then
            petCounts[petName] = petCounts[petName] + 1
        else
            petCounts[petName] = 1
            table.insert(petList, petName)
        end
    end

    _G.AllPetCounts = petCounts
    table.sort(petList)
    return petList
end

local info = rubyPet:AddParagraph("Info", {
    Title = "OP",
    Content = "You don't even need the pet to be shiny for this! It is recommend to use this instead of the shiny machine as it uses less pets, and gives you a better multiplier.",
})

-- Ruby dropdown
local RubyPetDropdown = rubyPet:AddDropdown("SelectPetsToRuby", {
    Title = "Select Pet(s) to Ruby",
    Description = "Select which pet(s) you want to convert to ruby.",
    Values = getAllPets(),
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Ruby status paragraph
local RubyStatusParagraph = rubyPet:AddParagraph("SelectedRubyPets", {
    Title = "Selected Pets",
    Content = "No pets selected"
})

local function updateSelectedRubyPetsDisplay()
    local selectedPets = RubyPetDropdown.Value or {}
    local content = ""
    local petCount = 0

    for petName, isSelected in pairs(selectedPets) do
        if isSelected then
            petCount = petCount + 1

            -- Get actual pet value
            local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")
            local petValue = nil

            for _, child in pairs(Pets:GetChildren()) do
                if child.Name == petName then
                    petValue = child.Value
                    break -- Only get one matching instance
                end
            end

            -- Add to content display
            if petValue ~= nil then
                content = content .. "• " .. petName .. " (" .. tostring(petValue) .. "x)\n"
            else
                content = content .. "• " .. petName .. " (Value: Not found)\n"
            end
        end
    end

    if petCount == 0 then
        content = "No pets selected"
    end

    RubyStatusParagraph:SetValue(content)
end


RubyPetDropdown:OnChanged(function()
    updateSelectedRubyPetsDisplay()
end)

rubyPet:AddButton({
    Title = "Refresh Pet List",
    Description = "Update the list of available pets",
    Callback = function()
        local updatedPets = getAllPets()
        RubyPetDropdown:SetValues(updatedPets)
        updateSelectedRubyPetsDisplay()
    end
})

-- Ruby chance dropdown
local RubyChanceDropdown = rubyPet:AddDropdown("SelectRubyChance", {
    Title = "Select Ruby Chance",
    Description = "Select the success chance percentage",
    Values = {"20%", "40%", "60%", "80%", "100%"},
    Multi = false,
    Default = "40%"
})

RubyChanceDropdown:OnChanged(function()
    local raw = RubyChanceDropdown.Value or "60%"
    local number = tonumber(tostring(raw):match("%d+")) or 60
    local result = number / 20
end)



local autoRubyEnabled = false
local autoRubyThread = nil

rubyPet:AddToggle("AutoRubyPetsToggle", {
    Title = "Auto Ruby Pets",
    Description = "Automatically converts selected pets into ruby versions based on selected chance",
    Default = false,
    Callback = function(Value)
        autoRubyEnabled = Value

        if autoRubyThread then
            task.cancel(autoRubyThread)
            autoRubyThread = nil
        end

        if autoRubyEnabled then
            autoRubyThread = task.spawn(function()
                while autoRubyEnabled do
                    local selectedPets = RubyPetDropdown.Value or {}
                    local chanceStr = RubyChanceDropdown.Value or "40%"
                    local selectedChance = tonumber(chanceStr:match("%d+")) or 40
                    local requiredAmount = math.floor(selectedChance / 20)
                    local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")

                    for petName, isSelected in pairs(selectedPets) do
                        if isSelected then
                            -- Get pet value instead of counting instances
                            local petValue = 0
                            for _, child in pairs(Pets:GetChildren()) do
                                if child.Name == petName then
                                    petValue = child.Value
                                    break
                                end
                            end

                            if petValue >= requiredAmount and requiredAmount > 0 then
                                pcall(function()
                                    ReplicatedStorage.Remotes.CraftFunction:InvokeServer(
                                        "Ruby",
                                        petName,
                                        requiredAmount
                                    )
                                end)
                                updateSelectedRubyPetsDisplay()
                            end
                        end
                    end

                    task.wait(2)
                end
            end)
        end
    end
})

local goldpet = Tabs.Pet:AddSection("Shiny Machine")

-- Function to get player's pets excluding Golden and Ruby pets
local function getPlayerPets()
    local petList = {}
    local petCounts = {}
    local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")
    
    for _, child in pairs(Pets:GetChildren()) do
        local petName = child.Name
        
        -- Skip pets that have Golden or Ruby in their name
        if not string.find(petName, "Shiny") and not string.find(petName, "Ruby") then
            -- Count occurrences of each pet
            if petCounts[petName] then
                petCounts[petName] = petCounts[petName] + 1
            else
                petCounts[petName] = 1
                table.insert(petList, petName)
            end
        end
    end
    
    -- Store counts separately for reference
    _G.PetCounts = petCounts
    
    -- Sort alphabetically
    table.sort(petList)
    
    return petList
end

-- Create dropdown for selecting pets to gold
local GoldPetDropdown = goldpet:AddDropdown("SelectPetsToGold", {
    Title = "Select Pet(s) to Shiny",
    Description = "Select which pets to convert to shiny.",
    Values = getPlayerPets(),
    Multi = true,
    Searchable = true,
    Default = {}
})

-- Add status paragraph to show selected pets
local PetStatusParagraph = goldpet:AddParagraph("SelectedPets", {
    Title = "Selected Pets",
    Content = "No pets selected"
})

-- Function to update selected pets paragraph
local function updateSelectedPetsDisplay()
    local selectedPets = GoldPetDropdown.Value or {}
    local content = ""
    local petCount = 0

    for petName, isSelected in pairs(selectedPets) do
        if isSelected then
            petCount = petCount + 1

            -- Get the actual pet value from the data folder
            local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")
            local petValue = nil

            for _, child in pairs(Pets:GetChildren()) do
                if child.Name == petName then
                    petValue = child.Value
                    break -- Only show one instance's value
                end
            end

            -- Show pet name and value
            if petValue ~= nil then
                content = content .. "• " .. petName .. " (" .. tostring(petValue.."x") .. ")\n"
            else
                content = content .. "• " .. petName .. " (Value: Not found)\n"
            end

            -- Try to get pet stats
            pcall(function()
                local PetsData = require(ReplicatedStorage:WaitForChild("Data"):WaitForChild("Pets"))
                local petData = PetsData[petName]
                if petData then
                    if petData.taps then
                        content = content .. "  Taps: +" .. petData.taps .. "\n"
                    end
                    if petData.rebirths then
                        content = content .. "  Rebirths: +" .. petData.rebirths .. "\n"
                    end
                    if petData.luck then
                        content = content .. "  Luck: +" .. petData.luck .. "\n"
                    end
                    content = content .. "\n"
                end
            end)
        end
    end

    if petCount == 0 then
        content = "No pets selected"
    end

    PetStatusParagraph:SetValue(content)
end

-- Update display when selection changes
GoldPetDropdown:OnChanged(function()
    updateSelectedPetsDisplay()
end)

-- Button to refresh pet list
goldpet:AddButton({
    Title = "Refresh Pet List",
    Description = "Update the list of available pets",
    Callback = function()
        local updatedPets = getPlayerPets()
        GoldPetDropdown:SetValues(updatedPets)
        updateSelectedPetsDisplay()
    end
})

-- Create dropdown for selecting chance percentage
local ChanceDropdown = goldpet:AddDropdown("SelectGoldChance", {
    Title = "Select Chance",
    Description = "Select the success chance percentage",
    Values = {"10%", "20%", "30%", "40%", "50%", "60%", "70%", "80%", "90%", "100%"},
    Multi = false,
    Default = "50%"
})

-- Update display when chance selection changes
ChanceDropdown:OnChanged(function()
    local raw = ChanceDropdown.Value or "50%"
    local value = tostring(raw) -- ensure it's a string
    local number = tonumber(value:match("%d+")) -- extract numeric part safely
    if number then
    end
end)

local autoGoldEnabled = false
local autoGoldThread = nil

goldpet:AddToggle("AutoGoldPetsToggle", {
    Title = "Auto Shiny Pets",
    Description = "Automatically converts selected pets into shiny versions based on selected chance",
    Default = false,
    Callback = function(Value)
        autoGoldEnabled = Value

        -- Stop existing thread if running
        if autoGoldThread then
            task.cancel(autoGoldThread)
            autoGoldThread = nil
        end

        if autoGoldEnabled then
            autoGoldThread = task.spawn(function()
                while autoGoldEnabled do
                    local selectedPets = GoldPetDropdown.Value or {}
                    local chanceStr = ChanceDropdown.Value or "50%"
                    local selectedChance = tonumber(chanceStr:match("%d+")) or 50
                    local requiredAmount = math.floor(selectedChance / 10)
                    local Pets = game:GetService("Players").LocalPlayer:WaitForChild("Data"):WaitForChild("Pets")

                    for petName, isSelected in pairs(selectedPets) do
                        if isSelected then
                            -- Get pet value (quantity)
                            local petValue = 0
                            for _, child in pairs(Pets:GetChildren()) do
                                if child.Name == petName then
                                    petValue = child.Value
                                    break
                                end
                            end

                            if petValue >= requiredAmount and requiredAmount > 0 then
                                pcall(function()
                                    ReplicatedStorage.Remotes.CraftFunction:InvokeServer(
                                        "Shiny",
                                        petName,
                                        requiredAmount
                                    )
                                    updateSelectedPetsDisplay()
                                end)
                            end
                        end
                    end

                    task.wait(2)
                end
            end)
        end
    end
})

local merchantsection = Tabs.Merchant:AddSection("Merchant")

local merchantStatusParagraph = merchantsection:Paragraph("MerchantStatus", {
    Title = "Current Merchant Stock",
    Content = "Loading merchant stock... \n"
})

local function updateMerchantStatus()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local merchantHolder

    -- Safely get merchant holder
    pcall(function()
        merchantHolder = player.PlayerGui:WaitForChild("MainHUD", 2)
            :WaitForChild("Frames", 2)
            :WaitForChild("Merchant", 2)
            :WaitForChild("Main", 2)
            :WaitForChild("Holder", 2)
    end)

    if not merchantHolder then
        merchantStatusParagraph:SetValue("Merchant UI not found.")
        return
    end

    -- Get timer and remove "Resets in"
    local resetTime = merchantHolder.Parent:FindFirstChild("resetTime")
    local timerText = resetTime and resetTime.Text or "Timer: N/A"
    timerText = timerText:gsub("Resets in", ""):gsub("^%s+", "") -- Remove "Resets in" and leading spaces

    -- Gather items by slot
    local lines = {"Timer: " .. timerText.. "\n"}
    local slotNum = 1
    for _, frame in pairs(merchantHolder:GetChildren()) do
        if frame:IsA("Frame") and frame.Visible then
            local itemName = frame:FindFirstChild("TextLabel")
            local itemCost = frame:FindFirstChild("Amount") and frame.Amount:FindFirstChild("TextLabel")
            if itemName and itemCost then
                table.insert(lines, string.format("Slot %d: %s - %s Gems", slotNum, itemName.Text, itemCost.Text))
                slotNum = slotNum + 1
            end
        end
    end

    if #lines == 1 then
        table.insert(lines, "No merchant items found, or sold out.")
    end

    merchantStatusParagraph:SetValue(table.concat(lines, "\n"))
end

-- Update the merchant status every 5 seconds
task.spawn(function()
    while true do
        updateMerchantStatus()
        task.wait(1)
    end
end)

local merchantModule = require(game:GetService("ReplicatedStorage").Data:WaitForChild("Merchant"))

-- Gather all merchant item names
local merchantItemNames = {}
for _, item in pairs(merchantModule) do
    if item.name then
        table.insert(merchantItemNames, item.name)
    end
end
table.sort(merchantItemNames)

-- Add the dropdown to the Merchant tab/section
local MerchantDropdown = Tabs.Merchant:AddDropdown("MerchantItemsDropdown", {
    Title = "Select Merchant Items",
    Description = "Choose one or more merchant items.",
    Values = merchantItemNames,
    Multi = true,
    Searchable = true,
    Default = {}
})

local autoBuyMerchantEnabled = false
local autoBuyMerchantThread = nil

Tabs.Merchant:AddToggle("AutoBuyMerchantItems", {
    Title = "Auto Buy Items",
    Description = "Automatically buys selected merchant items if you can afford them and they are available.",
    Default = false,
    Callback = function(Value)
        autoBuyMerchantEnabled = Value

        if autoBuyMerchantThread then
            task.cancel(autoBuyMerchantThread)
            autoBuyMerchantThread = nil
        end

        if autoBuyMerchantEnabled then
            autoBuyMerchantThread = task.spawn(function()
                local Players = game:GetService("Players")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local player = Players.LocalPlayer
                local merchantRemote = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("merchantEvent")
                local playerData = player:WaitForChild("Data")
                local gemsObject = playerData:WaitForChild("Gems")

                while autoBuyMerchantEnabled do
                    local success, merchantHolder = pcall(function()
                        return player.PlayerGui
                            :WaitForChild("MainHUD", 2)
                            :WaitForChild("Frames", 2)
                            :WaitForChild("Merchant", 2)
                            :WaitForChild("Main", 2)
                            :WaitForChild("Holder", 2)
                    end)

                    if success and merchantHolder then
                        local selectedItems = MerchantDropdown.Value or {}
                        local playerGems = gemsObject and gemsObject.Value or 0

                        for _, frame in pairs(merchantHolder:GetChildren()) do
                            if frame:IsA("Frame") and frame.Visible then
                                local itemNameLabel = frame:FindFirstChild("TextLabel")
                                local amountFrame = frame:FindFirstChild("Amount")
                                local itemCostLabel = amountFrame and amountFrame:FindFirstChild("TextLabel")
                                local slotName = frame.Name

                                if itemNameLabel and itemCostLabel and slotName then
                                    local itemName = itemNameLabel.Text
                                    local rawCostText = itemCostLabel.Text
                                    local cleanedCost = rawCostText:gsub(",", ""):gsub("[^%d%.]", "")
                                    local itemCost = tonumber(cleanedCost) or 0

                                    if selectedItems[itemName] and playerGems >= itemCost and itemCost > 0 then
                                        pcall(function()
                                            merchantRemote:FireServer(itemName)
                                            frame.Visible = false
                                        end)

                                        task.wait(0.5)
                                    end
                                end
                            end
                        end
                    end

                    task.wait(2)
                end
            end)
        end
    end
})



-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}


InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

local antiafk = Tabs.Settings:AddSection("Anti AFK")

Tabs.Settings:AddButton({
    Title = "Anti Afk",
    Description = "Never get kicked for being inactive.",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()
        Library:Notify({
            Title = "Anti Afk",
            Content = "Anti Afk active!",
            Duration = 4
        })
    end
})


local usercountsection = Tabs.Settings:AddSection("User Count")

local userCountParagraph = Tabs.Settings:AddParagraph("UserCountStatus", {
    Title = "Script User Count",
    Content = "Loading..."
})


-- Step 1: Register the user
local registerResponse = requestFunc({
    Url = "https://duckyscripts.pythonanywhere.com/api/tap/add-user",
    Method = "POST",
    Headers = {
        ["Content-Type"] = "application/json"
    },
    Body = HttpService:JSONEncode({
        username = username,
        userid = userid
    })
})

if registerResponse and registerResponse.Body then
end


task.spawn(function()
    while true do
        local heartbeatResponse = requestFunc({
            Url = "https://duckyscripts.pythonanywhere.com/api/tap/active",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode({
                userid = userid,
                active = true
            })
        })

        if heartbeatResponse and heartbeatResponse.Body then
            local responseBody = heartbeatResponse.Body
            local data = HttpService:JSONDecode(responseBody)
            local activeCount = data.active_count or 0
            local totalCount = data.count or 0
            userCountParagraph:SetValue(tostring ("Total users: " .. tostring(totalCount) .. "\n" .. "Active Users: " .. tostring(activeCount)))
        end

        task.wait(30) 
    end
end)



InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab("Settings")    

SaveManager:LoadAutoloadConfig()
